#include <stdio.h>
#include <stdlib.h>
#include <dbus/dbus.h>
#include "ClientEnclave_u.h"// generated by sgx_edger8r

const char *version = "0.1";
const char *iface = "br.ufpr.inf.larsis.UniSGXInterface";
const char *serverName = "br.ufpr.inf.larsis.UniSGX";
const char *objectPath = "/br/ufpr/inf/larsis/Object";
DBusConnection* conn;

void ocall_print_int(int i) {
	printf("%d\n", i);
}

void ocall_print_pointer( char *s) { 
	printf("%s",s);
}

// void ocall_print_int( int s)
// {
 
//  printf("int: %d\n",s);

// }

sgx_status_t save_data(const char* fileName, void* data, long length) {
	FILE *fp = fopen(fileName, "ab");

	if(!fp){
		return SGX_ERROR_UNEXPECTED;
	}

	int ret = fwrite(data, sizeof(uint8_t), length, fp);

	fclose(fp);

	if (ret != length) {
		printf("writeFile: Error %d\n", ret);
		return SGX_ERROR_UNEXPECTED;
	}

	return SGX_SUCCESS;
}

void ocall_sleep(void) {
 	printf("%s\n","sleepping 5sec..." );
	sleep(5);
}

void ocall_print(const char *c) {
	printf("%s\n", c);
}

void ocall_session_request(sgx_enclave_id_t enclave_id, sgx_dh_msg1_t *dh_msg1){
	sgx_status_t ret = SGX_SUCCESS;
	DBusError err;
	DBusMessage* reply;
	DBusMessage* msg;
	char *pReadData;
	int len;

	dbus_error_init(&err);

	conn = dbus_bus_get(DBUS_BUS_SESSION, &err);
	if (dbus_error_is_set(&err)) { 
		fprintf(stderr, "Connection Error (%s)\n", err.message); 
		dbus_error_free(&err);
	}
	if (conn == NULL) {
		return;
	}

	ret = dbus_bus_request_name(conn, "br.ufpr.inf.larsis.UniSGXClient", DBUS_NAME_FLAG_REPLACE_EXISTING , &err);
	if (dbus_error_is_set(&err)) { 
		fprintf(stderr, "Name Error (%s)\n", err.message); 
		dbus_error_free(&err);
	}

	msg = dbus_message_new_method_call(serverName, // target for the method call
                                      objectPath, // object to call on
                                      iface, // interface to call on
                                      "session_request"); // method name
	if (msg == NULL) {
		return;
	}

	dbus_message_append_args(msg, DBUS_TYPE_UINT64, &enclave_id, DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block(conn, msg, DBUS_TIMEOUT_USE_DEFAULT, &err);

	if (!dbus_message_get_args(reply, &err, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pReadData, &len, DBUS_TYPE_INVALID)) {
		fprintf(stderr, "Args ERROR\n");
		return;
	}

	if (len > 0) {
		memcpy(dh_msg1, pReadData, len);
	} else {
		fprintf(stderr, "Args NULL\n");
		return;
	}

	dbus_message_unref(msg);
	dbus_message_unref(reply);
}

void ocall_exchange_report(sgx_enclave_id_t enclave_id, sgx_dh_msg2_t *dh_msg2, sgx_dh_msg3_t *dh_msg3, sgx_key_128bit_t *dh_aek){
	sgx_status_t ret = SGX_SUCCESS;
	DBusError err;
	DBusMessage* reply;
	DBusMessage* msg;
	char *p_read_dh_msg3, *p_read_dh_aek;
	int len_dh_msg3, len_dh_aek;

	dbus_error_init(&err);

	msg = dbus_message_new_method_call(serverName, // target for the method call
                                      objectPath, // object to call on
                                      iface, // interface to call on
                                      "exchange_report"); // method name
	if (msg == NULL) {
		return;
	}

	dbus_message_append_args(msg, DBUS_TYPE_UINT64, &enclave_id, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &dh_msg2, sizeof(sgx_dh_msg2_t), DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block(conn, msg, DBUS_TIMEOUT_USE_DEFAULT, &err);

	if (!dbus_message_get_args(reply, &err, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &p_read_dh_msg3, &len_dh_msg3, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &p_read_dh_aek, &len_dh_aek, DBUS_TYPE_INVALID)) {
		fprintf(stderr, "Args ERROR\n");
		return;
	}

	if ((len_dh_msg3 > 0) && (len_dh_aek > 0)) {
		memcpy(dh_msg3, p_read_dh_msg3, len_dh_msg3);
		memcpy(dh_aek, p_read_dh_aek, len_dh_aek);
	} else {
		fprintf(stderr, "Args NULL\n");
		return;
	}

	dbus_message_unref(msg);
	dbus_message_unref(reply);
}

void ocall_send_request(sgx_enclave_id_t enclave_id, sgx_aes_gcm_data_t* message, size_t message_size, sgx_aes_gcm_data_t* response, size_t response_size, uint8_t* error){
	sgx_status_t ret = SGX_SUCCESS;
	DBusError err;
	DBusMessage* reply;
	DBusMessage* msg;
	char *pReadData;
	int len;

	dbus_error_init(&err);

	msg = dbus_message_new_method_call(serverName, // target for the method call
                                      objectPath, // object to call on
                                      iface, // interface to call on
                                      "verify_password"); // method name
	if (msg == NULL) {
		return;
	}

	dbus_message_append_args(msg, DBUS_TYPE_UINT64, &enclave_id, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &message, message_size, DBUS_TYPE_INVALID);

	reply = dbus_connection_send_with_reply_and_block(conn, msg, DBUS_TIMEOUT_USE_DEFAULT, &err);

	if (!dbus_message_get_args(reply, &err, DBUS_TYPE_BYTE, error, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pReadData, &len, DBUS_TYPE_INVALID)) {
		printf("Args ERROR\n");
		return;
	}

	if (*error == 0) {
		if (len == response_size) {
			memcpy(response, pReadData, len);
			//printf("Len %d\n", len);
		} else {
			*error = 1;
		}
	}

	dbus_message_unref(msg);
	dbus_message_unref(reply);

	//ret = Enclave2_ecall_receive_message(dest_enclave_id, message, message_size);
}
